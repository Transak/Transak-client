'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findNearestPackageJson = undefined;

let findNearestPackageJson = exports.findNearestPackageJson = (() => {
  var _ref = _asyncToGenerator(function* (directoryPath = path.resolve()) {
    try {
      const packageJsonPath = path.join(directoryPath, 'package.json');
      const packageJsonData = JSON.parse((yield readFile(packageJsonPath)));
      return {
        path: packageJsonPath,
        data: packageJsonData
      };
    } catch (error) {
      const parentDirectoryPath = path.dirname(directoryPath);
      if (parentDirectoryPath === directoryPath) {
        throw new Error('No package.json files found');
      }
      return findNearestPackageJson(parentDirectoryPath);
    }
  });

  return function findNearestPackageJson() {
    return _ref.apply(this, arguments);
  };
})();

exports.findNearestPackageJsonSync = findNearestPackageJsonSync;

var _fs = require('fs');

var fs = _interopRequireWildcard(_fs);

var _path = require('path');

var path = _interopRequireWildcard(_path);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function readFile(filePath) {
  return new Promise((resolve, reject) => {
    fs.readFile(filePath, 'utf8', (error, result) => {
      if (error) reject(error);else resolve(result);
    });
  });
}

function findNearestPackageJsonSync(directoryPath = path.resolve()) {
  try {
    const packageJsonPath = path.join(directoryPath, 'package.json');
    const packageJsonData = JSON.parse(readFileSync(packageJsonPath));
    return {
      path: packageJsonPath,
      data: packageJsonData
    };
  } catch (error) {
    const parentDirectoryPath = path.dirname(directoryPath);
    if (parentDirectoryPath === directoryPath) {
      throw new Error('No package.json files found');
    }
    return findNearestPackageJsonSync(parentDirectoryPath);
  }
}

function readFileSync(filePath) {
  return fs.readFileSync(filePath, 'utf8');
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbImRpcmVjdG9yeVBhdGgiLCJwYXRoIiwicmVzb2x2ZSIsInBhY2thZ2VKc29uUGF0aCIsImpvaW4iLCJwYWNrYWdlSnNvbkRhdGEiLCJKU09OIiwicGFyc2UiLCJyZWFkRmlsZSIsImRhdGEiLCJlcnJvciIsInBhcmVudERpcmVjdG9yeVBhdGgiLCJkaXJuYW1lIiwiRXJyb3IiLCJmaW5kTmVhcmVzdFBhY2thZ2VKc29uIiwiZmluZE5lYXJlc3RQYWNrYWdlSnNvblN5bmMiLCJmcyIsImZpbGVQYXRoIiwiUHJvbWlzZSIsInJlamVjdCIsInJlc3VsdCIsInJlYWRGaWxlU3luYyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7K0JBY08sV0FDTEEsZ0JBQXdCQyxLQUFLQyxPQUFMLEVBRG5CLEVBRXlDO0FBQzlDLFFBQUk7QUFDRixZQUFNQyxrQkFBa0JGLEtBQUtHLElBQUwsQ0FBVUosYUFBVixFQUF5QixjQUF6QixDQUF4QjtBQUNBLFlBQU1LLGtCQUFrQkMsS0FBS0MsS0FBTCxFQUFXLE1BQU1DLFNBQVNMLGVBQVQsQ0FBakIsRUFBeEI7QUFDQSxhQUFPO0FBQ0xGLGNBQU1FLGVBREQ7QUFFTE0sY0FBTUo7QUFGRCxPQUFQO0FBSUQsS0FQRCxDQU9FLE9BQU9LLEtBQVAsRUFBYztBQUNkLFlBQU1DLHNCQUFzQlYsS0FBS1csT0FBTCxDQUFhWixhQUFiLENBQTVCO0FBQ0EsVUFBSVcsd0JBQXdCWCxhQUE1QixFQUEyQztBQUN6QyxjQUFNLElBQUlhLEtBQUosQ0FBVSw2QkFBVixDQUFOO0FBQ0Q7QUFDRCxhQUFPQyx1QkFBdUJILG1CQUF2QixDQUFQO0FBQ0Q7QUFDRixHOztrQkFqQnFCRyxzQjs7Ozs7UUE0Qk5DLDBCLEdBQUFBLDBCOztBQXpDaEI7O0lBQVlDLEU7O0FBQ1o7O0lBQVlmLEk7Ozs7OztBQStCWixTQUFTTyxRQUFULENBQWtCUyxRQUFsQixFQUFxRDtBQUNuRCxTQUFPLElBQUlDLE9BQUosQ0FBWSxDQUFDaEIsT0FBRCxFQUFVaUIsTUFBVixLQUFxQjtBQUN0Q0gsT0FBR1IsUUFBSCxDQUFZUyxRQUFaLEVBQXNCLE1BQXRCLEVBQThCLENBQUNQLEtBQUQsRUFBUVUsTUFBUixLQUFtQjtBQUMvQyxVQUFJVixLQUFKLEVBQVdTLE9BQU9ULEtBQVAsRUFBWCxLQUNLUixRQUFRa0IsTUFBUjtBQUNOLEtBSEQ7QUFJRCxHQUxNLENBQVA7QUFNRDs7QUFFTSxTQUFTTCwwQkFBVCxDQUNMZixnQkFBd0JDLEtBQUtDLE9BQUwsRUFEbkIsRUFFZ0M7QUFDckMsTUFBSTtBQUNGLFVBQU1DLGtCQUFrQkYsS0FBS0csSUFBTCxDQUFVSixhQUFWLEVBQXlCLGNBQXpCLENBQXhCO0FBQ0EsVUFBTUssa0JBQWtCQyxLQUFLQyxLQUFMLENBQVdjLGFBQWFsQixlQUFiLENBQVgsQ0FBeEI7QUFDQSxXQUFPO0FBQ0xGLFlBQU1FLGVBREQ7QUFFTE0sWUFBTUo7QUFGRCxLQUFQO0FBSUQsR0FQRCxDQU9FLE9BQU9LLEtBQVAsRUFBYztBQUNkLFVBQU1DLHNCQUFzQlYsS0FBS1csT0FBTCxDQUFhWixhQUFiLENBQTVCO0FBQ0EsUUFBSVcsd0JBQXdCWCxhQUE1QixFQUEyQztBQUN6QyxZQUFNLElBQUlhLEtBQUosQ0FBVSw2QkFBVixDQUFOO0FBQ0Q7QUFDRCxXQUFPRSwyQkFBMkJKLG1CQUEzQixDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTVSxZQUFULENBQXNCSixRQUF0QixFQUFnRDtBQUM5QyxTQUFPRCxHQUFHSyxZQUFILENBQWdCSixRQUFoQixFQUEwQixNQUExQixDQUFQO0FBQ0QiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBAZmxvdyAqL1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnXG5cbnR5cGUgUGFja2FnZUpzb24gPSB7XG4gIG5hbWU6IHN0cmluZyxcbiAgdmVyc2lvbj86IHN0cmluZyxcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmcsXG4gIG1haW4/OiBzdHJpbmcsXG4gIHNjcmlwdHM/OiB7IFtzdHJpbmddOiBzdHJpbmcgfSxcbiAgZGVwZW5kZW5jaWVzPzogeyBbc3RyaW5nXTogc3RyaW5nIH0sXG4gIGRldkRlcGVuZGVuY2llcz86IHsgW3N0cmluZ106IHN0cmluZyB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmaW5kTmVhcmVzdFBhY2thZ2VKc29uKFxuICBkaXJlY3RvcnlQYXRoOiBzdHJpbmcgPSBwYXRoLnJlc29sdmUoKVxuKTogUHJvbWlzZTx7IHBhdGg6IHN0cmluZywgZGF0YTogUGFja2FnZUpzb24gfT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHBhY2thZ2VKc29uUGF0aCA9IHBhdGguam9pbihkaXJlY3RvcnlQYXRoLCAncGFja2FnZS5qc29uJylcbiAgICBjb25zdCBwYWNrYWdlSnNvbkRhdGEgPSBKU09OLnBhcnNlKGF3YWl0IHJlYWRGaWxlKHBhY2thZ2VKc29uUGF0aCkpXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHBhY2thZ2VKc29uUGF0aCxcbiAgICAgIGRhdGE6IHBhY2thZ2VKc29uRGF0YVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBwYXJlbnREaXJlY3RvcnlQYXRoID0gcGF0aC5kaXJuYW1lKGRpcmVjdG9yeVBhdGgpXG4gICAgaWYgKHBhcmVudERpcmVjdG9yeVBhdGggPT09IGRpcmVjdG9yeVBhdGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcGFja2FnZS5qc29uIGZpbGVzIGZvdW5kJylcbiAgICB9XG4gICAgcmV0dXJuIGZpbmROZWFyZXN0UGFja2FnZUpzb24ocGFyZW50RGlyZWN0b3J5UGF0aClcbiAgfVxufVxuXG5mdW5jdGlvbiByZWFkRmlsZShmaWxlUGF0aDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmcy5yZWFkRmlsZShmaWxlUGF0aCwgJ3V0ZjgnLCAoZXJyb3IsIHJlc3VsdCkgPT4ge1xuICAgICAgaWYgKGVycm9yKSByZWplY3QoZXJyb3IpXG4gICAgICBlbHNlIHJlc29sdmUocmVzdWx0KVxuICAgIH0pXG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTmVhcmVzdFBhY2thZ2VKc29uU3luYyhcbiAgZGlyZWN0b3J5UGF0aDogc3RyaW5nID0gcGF0aC5yZXNvbHZlKClcbik6IHsgcGF0aDogc3RyaW5nLCBkYXRhOiBQYWNrYWdlSnNvbiB9IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYWNrYWdlSnNvblBhdGggPSBwYXRoLmpvaW4oZGlyZWN0b3J5UGF0aCwgJ3BhY2thZ2UuanNvbicpXG4gICAgY29uc3QgcGFja2FnZUpzb25EYXRhID0gSlNPTi5wYXJzZShyZWFkRmlsZVN5bmMocGFja2FnZUpzb25QYXRoKSlcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogcGFja2FnZUpzb25QYXRoLFxuICAgICAgZGF0YTogcGFja2FnZUpzb25EYXRhXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IHBhcmVudERpcmVjdG9yeVBhdGggPSBwYXRoLmRpcm5hbWUoZGlyZWN0b3J5UGF0aClcbiAgICBpZiAocGFyZW50RGlyZWN0b3J5UGF0aCA9PT0gZGlyZWN0b3J5UGF0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwYWNrYWdlLmpzb24gZmlsZXMgZm91bmQnKVxuICAgIH1cbiAgICByZXR1cm4gZmluZE5lYXJlc3RQYWNrYWdlSnNvblN5bmMocGFyZW50RGlyZWN0b3J5UGF0aClcbiAgfVxufVxuXG5mdW5jdGlvbiByZWFkRmlsZVN5bmMoZmlsZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4Jylcbn1cbiJdfQ==